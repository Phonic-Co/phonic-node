/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as environments from "../../../../environments.js";
import * as core from "../../../../core/index.js";
import { StsSocket } from "./Socket.js";

export declare namespace Sts {
    export interface Options {
        environment?: core.Supplier<environments.PhonicEnvironment | environments.PhonicEnvironmentUrls>;
        /** Specify a custom URL to connect the client to. */
        baseUrl?: core.Supplier<string>;
        token: core.Supplier<core.BearerToken>;
        /** Additional headers to include in requests. */
        headers?: Record<string, string | core.Supplier<string | undefined> | undefined>;
        fetcher?: core.FetchFunction;
    }

    export interface ConnectArgs {
        downstream_websocket_url?: string;
        /** Arbitrary headers to send with the websocket connect request. */
        headers?: Record<string, string>;
        /** Enable debug mode on the websocket. Defaults to false. */
        debug?: boolean;
        /** Number of reconnect attempts. Defaults to 30. */
        reconnectAttempts?: number;
    }
}

export class Sts {
    protected readonly _options: Sts.Options;
    private pendingMessages: Array<() => void> = [];
    private isConnected = false;
    private socket: StsSocket | null = null;

    constructor(_options: Sts.Options) {
        this._options = _options;
    }

    private withBuffer<T extends unknown[]>(fn: (...args: T) => void) {
        return (...args: T) => {
            const action = () => fn(...args);
            if (this.isConnected && this.socket) {
                action();
            } else {
                this.pendingMessages.push(action);
            }
        };
    }

    private flushPendingMessages(): void {
        this.isConnected = true;
        this.pendingMessages.splice(0).forEach((action) => action());
    }

    public async connect(args?: Sts.ConnectArgs): Promise<StsSocket> {
        const { downstream_websocket_url, headers, debug, reconnectAttempts } = args ?? {};
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (downstream_websocket_url != null) {
            _queryParams["downstream_websocket_url"] = downstream_websocket_url;
        }
        let _headers: Record<string, string> = {
            ...headers,
        };
        _headers["Authorization"] = await this._getAuthorizationHeader();

        const socket = new core.ReconnectingWebSocket({
            url: core.url.join(
                (await core.Supplier.get(this._options["baseUrl"])) ??
                    ((await core.Supplier.get(this._options["environment"])) ?? environments.PhonicEnvironment.Default)
                        .production,
                "/v1/sts/ws",
            ),
            protocols: [],
            queryParameters: _queryParams,
            headers: _headers,
            options: { debug: debug ?? false, maxRetries: reconnectAttempts ?? 30 },
        });
        
        this.socket = new StsSocket({ socket });
        this.isConnected = false;

        this.socket.on("open", () => {
            this.flushPendingMessages();
        });

        this.socket.on("close", () => {
            this.isConnected = false;
        });

        this.socket.on("error", () => {
            this.isConnected = false;
        });

        const bufferedSocket = this.createBufferedSocket(this.socket);
        return bufferedSocket;
    }

    private createBufferedSocket(socket: StsSocket): StsSocket {
        const unbufferedSendConfig = socket.sendConfig.bind(socket);
        const unbufferedSendAudioChunk = socket.sendAudioChunk.bind(socket);
        const unbufferedSendUpdateSystemPrompt = socket.sendUpdateSystemPrompt.bind(socket);
        const unbufferedSendSetExternalId = socket.sendSetExternalId.bind(socket);
        const unbufferedSendSetTwilioCallSid = socket.sendSetTwilioCallSid.bind(socket);
        const unbufferedSendToolCallOutput = socket.sendToolCallOutput.bind(socket);

        socket.sendConfig = this.withBuffer(unbufferedSendConfig);
        socket.sendAudioChunk = this.withBuffer(unbufferedSendAudioChunk);
        socket.sendUpdateSystemPrompt = this.withBuffer(unbufferedSendUpdateSystemPrompt);
        socket.sendSetExternalId = this.withBuffer(unbufferedSendSetExternalId);
        socket.sendSetTwilioCallSid = this.withBuffer(unbufferedSendSetTwilioCallSid);
        socket.sendToolCallOutput = this.withBuffer(unbufferedSendToolCallOutput);

        return socket;
    }

    protected async _getAuthorizationHeader(): Promise<string> {
        return `Bearer ${await core.Supplier.get(this._options.token)}`;
    }
}
