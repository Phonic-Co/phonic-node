/**
 * This file was auto-generated by Fern from our API Definition.
 */

import * as core from "../../../../core/index.js";
import * as Phonic from "../../../index.js";
import { fromJson, toJson } from "../../../../core/json.js";

export declare namespace ConversationsSocket {
    export interface Args {
        socket: core.ReconnectingWebSocket;
    }

    export type Response =
        | Phonic.ReadyToStartConversationPayload
        | Phonic.ConversationCreatedPayload
        | Phonic.InputTextPayload
        | Phonic.InputCancelledPayload
        | Phonic.UserStartedSpeakingPayload
        | Phonic.UserFinishedSpeakingPayload
        | Phonic.DtmfPayload
        | Phonic.ToolCallPayload
        | Phonic.ToolCallOutputProcessedPayload
        | Phonic.ToolCallInterruptedPayload
        | Phonic.AssistantChoseNotToRespondPayload
        | Phonic.AssistantEndedConversationPayload
        | Phonic.ErrorPayload;
    type EventHandlers = {
        open?: () => void;
        message?: (message: Response) => void;
        close?: (event: core.CloseEvent) => void;
        error?: (error: Error) => void;
    };
}

export class ConversationsSocket {
    public readonly socket: core.ReconnectingWebSocket;
    protected readonly eventHandlers: ConversationsSocket.EventHandlers = {};
    private messageBuffer: (() => void)[] = [];
    private handleOpen: () => void = () => {
        this.flushMessageBuffer();
        this.eventHandlers.open?.();
    };
    private handleMessage: (event: { data: string }) => void = (event) => {
        const data = fromJson(event.data);

        this.eventHandlers.message?.(data as ConversationsSocket.Response);
    };
    private handleClose: (event: core.CloseEvent) => void = (event) => {
        this.eventHandlers.close?.(event);
    };
    private handleError: (event: core.ErrorEvent) => void = (event) => {
        const message = event.message;
        this.eventHandlers.error?.(new Error(message));
    };

    constructor(args: ConversationsSocket.Args) {
        this.socket = args.socket;
        this.socket.addEventListener("open", this.handleOpen);
        this.socket.addEventListener("message", this.handleMessage);
        this.socket.addEventListener("close", this.handleClose);
        this.socket.addEventListener("error", this.handleError);
    }

    /** The current state of the connection; this is one of the readyState constants. */
    get readyState(): number {
        return this.socket.readyState;
    }

    /**
     * @param event - The event to attach to.
     * @param callback - The callback to run when the event is triggered.
     * Usage:
     * ```typescript
     * this.on('open', () => {
     *     console.log('The websocket is open');
     * });
     * ```
     */
    public on<T extends keyof ConversationsSocket.EventHandlers>(
        event: T,
        callback: ConversationsSocket.EventHandlers[T],
    ) {
        this.eventHandlers[event] = callback;
    }

    public sendConfig(message: Phonic.ConfigPayload): void {
        this.sendWithBuffering(() => this.sendJson(message));
    }

    public sendAudioChunk(message: Phonic.AudioChunkPayload): void {
        this.sendWithBuffering(() => this.sendJson(message));
    }

    public sendUpdateSystemPrompt(message: Phonic.UpdateSystemPromptPayload): void {
        this.sendWithBuffering(() => this.sendJson(message));
    }

    public sendSetExternalId(message: Phonic.SetExternalIdPayload): void {
        this.sendWithBuffering(() => this.sendJson(message));
    }

    public sendSetTwilioCallSid(message: Phonic.SetTwilioCallSidPayload): void {
        this.sendWithBuffering(() => this.sendJson(message));
    }

    public sendToolCallOutput(message: Phonic.ToolCallOutputPayload): void {
        this.sendWithBuffering(() => this.sendJson(message));
    }

    /** Connect to the websocket and register event handlers. */
    public connect(): ConversationsSocket {
        this.socket.reconnect();

        this.socket.addEventListener("open", this.handleOpen);
        this.socket.addEventListener("message", this.handleMessage);
        this.socket.addEventListener("close", this.handleClose);
        this.socket.addEventListener("error", this.handleError);

        return this;
    }

    /** Close the websocket and unregister event handlers. */
    public close(): void {
        this.socket.close();

        this.handleClose({ code: 1000 } as CloseEvent);
        this.clearMessageBuffer();

        this.socket.removeEventListener("open", this.handleOpen);
        this.socket.removeEventListener("message", this.handleMessage);
        this.socket.removeEventListener("close", this.handleClose);
        this.socket.removeEventListener("error", this.handleError);
    }

    /** Returns a promise that resolves when the websocket is open. */
    public async waitForOpen(): Promise<core.ReconnectingWebSocket> {
        if (this.socket.readyState === core.ReconnectingWebSocket.OPEN) {
            return this.socket;
        }

        return new Promise((resolve, reject) => {
            this.socket.addEventListener("open", () => {
                resolve(this.socket);
            });

            this.socket.addEventListener("error", (event: unknown) => {
                reject(event);
            });
        });
    }

    /** Asserts that the websocket is open. */
    private assertSocketIsOpen(): void {
        if (!this.socket) {
            throw new Error("Socket is not connected.");
        }

        if (this.socket.readyState !== core.ReconnectingWebSocket.OPEN) {
            throw new Error("Socket is not open.");
        }
    }

    /** Send a message with buffering - if socket is not open, buffer the message. */
    private sendWithBuffering(sendFn: () => void): void {
        if (this.socket.readyState === core.ReconnectingWebSocket.OPEN) {
            sendFn();
        } else {
            this.messageBuffer.push(sendFn);
        }
    }

    /** Flush all buffered messages when the socket opens. */
    private flushMessageBuffer(): void {
        while (this.messageBuffer.length > 0) {
            const sendFn = this.messageBuffer.shift();
            if (sendFn) {
                try {
                    sendFn();
                } catch (error) {
                    console.error("Error sending buffered message:", error);
                }
            }
        }
    }

    /** Clear all buffered messages. */
    private clearMessageBuffer(): void {
        this.messageBuffer = [];
    }

    /** Send a binary payload to the websocket. */
    protected sendBinary(payload: ArrayBufferLike | Blob | ArrayBufferView): void {
        this.socket.send(payload as any);
    }

    /** Send a JSON payload to the websocket. */
    protected sendJson(
        payload:
            | Phonic.ConfigPayload
            | Phonic.AudioChunkPayload
            | Phonic.UpdateSystemPromptPayload
            | Phonic.SetExternalIdPayload
            | Phonic.SetTwilioCallSidPayload
            | Phonic.ToolCallOutputPayload,
    ): void {
        const jsonPayload = toJson(payload);
        this.socket.send(jsonPayload);
    }
}